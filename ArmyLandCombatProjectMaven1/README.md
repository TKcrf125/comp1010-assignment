# Army Land Combat

A warfare simulator, test your Tatics!!

## 1. Problem Statement

The aim of this project was to put a military spin on a turn based combat game while also hitting the projects assessment constraints and objectives. 

## 2. Project Structure

<!-- NOTE: Adapt directory names or descriptions if you reorganize folders locally -->

```
ArmyLandCombatProjectMaven1/
├── pom.xml                      # Maven configuration file
├── README.md                    # Project documentation (this file)
├── RESPONSIBILITIES.md          # Team contribution breakdown (fill in and sign)
├── scores.txt                   # Auto-generated by GameEngine to store scores
├── docs/
│   ├── ArmyLandCombat_UML.pum  # PlantUML source for class diagram
│   └── ArmyLandCombat_UML.pdf   # Generated UML diagram 
└── src/
    ├── main/java/
    │   └── combat/
    │       ├── ArmyLandCombat.java
    │       ├── engine/GameEngine.java
    │       ├── ui/ConsoleUI.java
    │       ├── util/InputUtil.java
    │       └── domain/
    │           ├── Troop.java
    │           ├── CombatTeam.java
    │           ├── EnemyTeam.java
    │           └── TroopNode.java
    └── test/java/combat/
        ├── EnemyTeamTest.java
        ├── TroopNodeTest.java
        ├── InputUtilTest.java
        ├── ConsoleUITest.java
        └── GameEngineTest.java
```

## 3. How to Run

1. go to the src file and open it 

2. go to ArmyLandCombat.java

3. run the code 

note: If you want the red to go away then click on each test and file but the game will run regardless. 
## 4. Features

* **Turn‑based combat**: pressing 1 for attack or 2 for defending in each round. 
* **Tutorial menu**: provides the three steps for playing the game.
* **Past‑Scores menu**: View scores in `scores.txt`.
* **Action history**: Recursive log of unit actions via `TroopNode`.
* **critical hits**: The chance that a unit will deal critical dammage acording to their crit chance.
* **special Ability**: Each unit has a specific special ability all special abilities have a cooldown. 

## 5. Task Allocation

| Team Member   | Contribution                                                 |
| ------------- | ------------------------------------------------------------ |
| **\<Tom Kilburn>** |  Establish turn-based sequence (attack/defend choices each round)
. Specify win/loss conditions (all enemy units defeated vs. player squad wiped out)
. Design units & stats
. Choose unit types (Infantry, Armored Platoon, Artillery, etc.)
. Set health, attackPower, defencePower for each
. Balance strengths/weaknesses so no one unit dominates
. Craft the tutorial flow
. Write the step-by-step “Tutorial” menu content
. Decide what tips/hints to show and in what order
. Lay out the UI
. write menu structure and prompts
. write the scoring system
. Choose formula for “score” (e.g. sum of remaining health + stats)
. Decide how and when to record scores to scores.txt
. Create the recursive history feature
. Decide what events to record in the TroopNode chain (e.g. each action taken)
. Determine how deep/value of history for post-game analysis
. design and implement files format
. Define the plain-text format of scores.txt (one number per line)
. Make the UML class diagram
. Map game concepts (engine, UI, domain) to classes & relationships
. Choose packages and package names
. Develop method-analysis write-up
. creating the game loop 
. Work with the Test Designer to ensure those scenarios are covered |
| **\<Asmi Jambhale>** | • Role: Editor and Test Designer 
Tasks: 
• Refactor and reorganise code into packages (engine, ui, domain, util)
• Standardise indentation (4-spaces) and brace style across all .java files
• Rename variables and methods for clarity 
• Extract helper methods to improve delegation 
• Add and update Javadoc on every public class and method
• Ensure all imports are correct 
• Verify Maven pom.xml is configured properly 
• Merge all branches and resolve conflicts, commit final code structure
Domain classes 
Engine features (GameEngine.buildTroopHistory(), file I/O, win/lose paths)
• Write and review test cases for normal and out of pocket scenarios (empty lists, invalid input loops, all-dead teams)
• Implement test classes: EnemyTeamTest, TroopNodeTest, InputUtilTest, ConsoleUITest, GameEngineTest
• Configure Maven Surefire plugin to run tests automatically with mvn test
• Ensure tests pass offline
• Measure basic coverage and add any missing critical paths
• Document in README the existence of unit tests and how to run them |

## 6. UML Class Diagram

![Class Diagram](docs/ArmyLandCombatUML.png)

(Also see [PDF version](docs/ArmyLandCombatUML.pdf) for full-size detail.)

## 7. Method Analysis

### `GameEngine.playGame()`
- **Purpose & Flow**  
  - Orchestrates the main turn-based loop:  
    1. Fetch next active `Troop` from player and enemy teams  
    2. Display status and prompt for Attack/Defend/Use Ability  
    3. Resolve player action (including critical hits or ability effects)  
    4. Resolve enemy counter-attack if still alive  
    5. Record action in the recursive `TroopNode` history  
    6. Repeat until one side is defeated, then show result and record score  
- **Alternative Designs**  
  - Could use an event-driven or state-machine pattern to decouple UI, logic and history  
  - Could split player/enemy turns into separate handler classes for cleaner SRP  
- **Complexity**  
  - Time: O(n) per turn (n = number of troops alive)  
  - Space: O(t) for action history (t = total actions recorded)

### `Troop.attack(Troop other)`
- **What It Does**  
  - Computes base damage = `max(0, attackPower – other.defencePower)`  
  - Rolls a random chance against `critChance`; if successful, multiplies damage by `critMultiplier` and prints a “Critical hit!” message  
  - Applies final damage via `other.takeDamage(damage)` and returns the damage dealt  
- **Alternative Designs**  
  - Could separate “damage calculation” and “hit determination” into distinct methods for testability  
  - Could introduce probability curves or hit/miss rolls for more nuanced combat  
- **Complexity**  
  - O(1) time and space (constant-time computation and no additional memory)

### `Ability.apply(Troop user, Troop target)`  
- **Function**  
  - Represents a one-off special action (e.g. “Barrage” or “First Aid”)  
  - In the example, doubles base damage or heals, applies effect to `target`, and returns a descriptive result string  
- **Alternative Designs**  
  - Could use a strategy pattern with subclassed `Ability` implementations for each unique effect  
  - Could parameterize effects (damage, heal, buff) in data rather than code for easier balance tweaks  
- **Complexity**  
  - O(1) time and space per use

---

## 8. Scope Requirements

1. **Object Containment**  
   - `TroopNode` holds a direct `Troop` reference (non-`List` containment) to build a recursive history.

2. **ArrayList Usage**  
   - `CombatTeam` and `EnemyTeam` each use `List<Troop>` (backed by `ArrayList`) to manage their squads.

3. **Recursive Data Structure**  
   - `TroopNode` forms a singly-linked list of unit actions and is built in `GameEngine.buildTroopHistory()`.

4. **File I/O**  
   - The game reads from and writes to a plain-text `scores.txt` in the project root to persist past scores.

5. **Ability Containment**  
   - Each `Troop` holds an `Ability` object (non-`List` containment), satisfying an additional user-defined reference requirement.

6. **Critical Hit Logic**  
   - `Troop.attack()` includes probabilistic behavior (`critChance`, `critMultiplier`), demonstrating conditional flow and RNG usage.

